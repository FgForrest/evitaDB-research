/*
 *                         _ _        ____  ____
 *               _____   _(_) |_ __ _|  _ \| __ )
 *              / _ \ \ / / | __/ _` | | | |  _ \
 *             |  __/\ V /| | || (_| | |_| | |_) |
 *              \___| \_/ |_|\__\__,_|____/|____/
 *
 *   Copyright (c) 2023
 *
 *   Licensed under the Business Source License, Version 1.1 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   https://github.com/FgForrest/evitaDB/blob/main/LICENSE
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package io.evitadb.api.schema;

import io.evitadb.api.CatalogBase;
import io.evitadb.api.data.ContentComparator;
import io.evitadb.api.data.structure.Entity;
import io.evitadb.api.io.extraResult.FacetSummary.FacetStatistics;
import io.evitadb.api.query.filter.*;
import io.evitadb.api.query.order.PriceAscending;
import io.evitadb.api.query.order.PriceDescending;
import io.evitadb.api.query.require.*;
import io.evitadb.api.utils.Assert;
import lombok.Data;
import lombok.EqualsAndHashCode;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.ThreadSafe;
import java.io.Serializable;
import java.util.*;
import java.util.Map.Entry;
import java.util.function.UnaryOperator;

/**
 * This is the definition object for {@link Entity}. Definition objects allow to describe the structure
 * of the entity type so that in any time everyone can consult complete structure of the entity type. Definition object
 * is similar to Java reflection process where you can also at any moment see which fields and methods are available
 * for the class.
 *
 * Based on our experience we've designed following data model for handling entities in Evita DB. Model is rather complex
 * but was designed to limit amount of data fetched from database and minimize an amount of data that are indexed and subject
 * to search.
 *
 * Minimal entity definition consists of:
 *
 * - entity type and
 * - primary key (even this is optional and may be autogenerated by the database).
 *
 * Other entity data is purely optional and may not be used at all.
 *
 * @author Jan Novotn√Ω (novotny@fg.cz), FG Forrest a.s. (c) 2021
 */
@Data
@Immutable
@ThreadSafe
@EqualsAndHashCode(of = {"version", "name"})
public class EntitySchema implements Serializable, ContentComparator<EntitySchema> {
	private static final long serialVersionUID = -209500573660545111L;
	private static final int ENTITY_SCHEMA_STRUCTURE_VERSION = 1;

	/**
	 * Contains version of this definition object and gets increased with any entity type update. Allows to execute
	 * optimistic locking i.e. avoiding parallel modifications.
	 */
	private final int version;
	/**
	 * Contains name of the entity. Case sensitive.
	 * Name must be unique among all entity types in the same {@link CatalogBase}.
	 *
	 * Serializable type of entity. Using Enum type is highly recommended for this key.
	 * Entity type is main sharding key - all data of entities with same type are stored in separated index. Within the
	 * entity type entity is uniquely represented by primary key.
	 * Type is specified in each lookup {@link io.evitadb.api.query.Query#getEntities()}
	 */
	private final Serializable name;
	/**
	 * Contains TRUE when primary keys of entities of this type will not be provided by the external systems and Evita
	 * is responsible for generating unique primary keys for the entity on insertion.
	 *
	 * Generated key is guaranteed to be unique, but may not represent continuous ascending series. Generated key
	 * will be always greater than zero.
	 */
	private final boolean withGeneratedPrimaryKey;
	/**
	 * Contains TRUE when entities of this type are organized in a tree like structure (hierarchy) where certain entities
	 * are subordinate of other entities.
	 *
	 * Entities may be organized in hierarchical fashion. That means that entity may refer to single parent entity and may be
	 * referred by multiple child entities. Hierarchy is always composed of entities of same type.
	 * Each entity must be part of at most single hierarchy (tree).
	 *
	 * Hierarchy can limit returned entities by using filtering constraints {@link WithinHierarchy}. It's also used for
	 * computation of extra data - such as {@link Parents}. It can also invert type of returned entities in case requirement
	 * {@link HierarchyStatistics} is used.
	 */
	private final boolean withHierarchy;
	/**
	 * Contains TRUE when entities of this type holds price information.
	 *
	 * Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce
	 * systems and highly affects performance of the entities filtering and sorting, they deserve first class support
	 * in entity model. It is pretty common in B2B systems single product has assigned dozens of prices for the different
	 * customers.
	 *
	 * Specifying prices on entity allows usage of {@link PriceValidIn}, {@link PriceInCurrency}
	 * {@link PriceBetween}, and {@link PriceInPriceLists} filtering constraints and also {@link PriceAscending},
	 * {@link PriceDescending} ordering of the entities. Additional requirements
	 * {@link PriceHistogram}, {@link Prices}, {@link QueryPriceMode} can be used in query as well.
	 */
	private final boolean withPrice;
	/**
	 * Determines how many fractional places are important when entities are compared during filtering or sorting. It is
	 * important to know that all prices will be converted to {@link java.lang.Integer}, so any of the price values
	 * (either with or without VAT) must not ever exceed maximum limits of {@link java.lang.Integer} type when scaling
	 * the number by the power of ten using {@link #getIndexedPricePlaces()} as exponent.
	 */
	private final int indexedPricePlaces;
	/**
	 * Contains set of all {@link Locale} that could be used for localized {@link AttributeSchema} or {@link AssociatedDataSchema}.
	 * Enables using {@link Language} filtering constraint in query.
	 */
	private final Set<Locale> locales;
	/**
	 * Contains index of all {@link AttributeSchema} that could be used as attributes of entity of this type.
	 *
	 * Entity (global) attributes allows defining set of data that are fetched in bulk along with the entity body.
	 * Attributes may be indexed for fast filtering ({@link AttributeSchema#isFilterable()}) or can be used to sort along
	 * ({@link AttributeSchema#isSortable()}). Attributes are not automatically indexed in order not to waste precious
	 * memory space for data that will never be used in search queries.
	 *
	 * Filtering in attributes is executed by using constraints like {@link io.evitadb.api.query.filter.And},
	 * {@link io.evitadb.api.query.filter.Not}, {@link io.evitadb.api.query.filter.Equals}, {@link io.evitadb.api.query.filter.Contains}
	 * and many others. Sorting can be achieved with {@link io.evitadb.api.query.order.Ascending},
	 * {@link io.evitadb.api.query.order.Descending} or others.
	 *
	 * Attributes are not recommended for bigger data as they are all loaded at once when {@link Attributes}
	 * requirement is used. Large data that are occasionally used store in {@link io.evitadb.api.data.structure.AssociatedData}.
	 */
	private final Map<String, AttributeSchema> attributes;
	/**
	 * Contains index of all {@link AssociatedDataSchema} that could be used as associated data of entity of this type.
	 *
	 * Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
	 * along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
	 * in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
	 * binary arrays representing entire files (i.e. pictures, documents).
	 *
	 * The search query must contain specific {@link AssociatedData} requirement in order
	 * associated data are fetched along with the entity. Associated data are stored and fetched separately by their name.
	 */
	private final Map<String, AssociatedDataSchema> associatedData;
	/**
	 * Contains index of all {@link ReferenceSchema} that could be used as references of entity of this type.
	 *
	 * References refer to other entities (of same or different entity type).
	 * Allows entity filtering (but not sorting) of the entities by using {@link Facet} constraint
	 * and statistics computation when {@link FacetStatistics} requirement is used. Reference
	 * is uniquely represented by int positive number (max. 2<sup>63</sup>-1) and {@link Serializable} entity type and can be
	 * part of multiple reference groups, that are also represented by int and {@link Serializable} entity type.
	 *
	 * Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
	 * of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
	 * to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
	 * group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
	 * Evita.
	 *
	 * References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
	 * The search query must contain specific {@link io.evitadb.api.query.require.References} requirement in order
	 * references are fetched along with the entity.
	 */
	private final Map<Serializable, ReferenceSchema> references;
	/**
	 * Evolution mode allows to specify how strict is Evita DB when unknown information is presented to her for the first
	 * time. When no evolution mode is set, each violation of the {@link EntitySchema} is
	 * reported by an exception. This behaviour can be changed by this evolution mode however.
	 */
	private final Set<EvolutionMode> evolutionMode;

	@SuppressWarnings("RedundantUnmodifiable")
	public EntitySchema(Serializable name) {
		this.version = 1;
		this.name = name;
		this.withGeneratedPrimaryKey = false;
		this.withHierarchy = false;
		this.withPrice = false;
		this.indexedPricePlaces = 2;
		//we need to wrap even empty map to the unmodifiable wrapper in order to unify type for Kryo serialization
		this.locales = Collections.unmodifiableSet(Collections.emptySet());
		this.references = Collections.unmodifiableMap(Collections.emptyMap());
		this.attributes = Collections.unmodifiableMap(Collections.emptyMap());
		this.associatedData = Collections.unmodifiableMap(Collections.emptyMap());
		this.evolutionMode = Collections.unmodifiableSet(EnumSet.allOf(EvolutionMode.class));
	}

	EntitySchema(int version, Serializable name, boolean withGeneratedPrimaryKey, boolean withHierarchy, boolean withPrice, int indexedPricePlaces, Set<Locale> locales, Map<String, AttributeSchema> attributes, Map<String, AssociatedDataSchema> associatedData, Map<Serializable, ReferenceSchema> references, Set<EvolutionMode> evolutionMode) {
		this.version = version;
		this.name = name;
		this.withGeneratedPrimaryKey = withGeneratedPrimaryKey;
		this.withHierarchy = withHierarchy;
		this.withPrice = withPrice;
		this.indexedPricePlaces = indexedPricePlaces;
		this.locales = Collections.unmodifiableSet(locales);
		this.attributes = Collections.unmodifiableMap(attributes);
		this.associatedData = Collections.unmodifiableMap(associatedData);
		this.references = Collections.unmodifiableMap(references);
		this.evolutionMode = Collections.unmodifiableSet(evolutionMode);
	}

	/**
	 * Returns definition of the attribute of particular name.
	 */
	@Nullable
	public AttributeSchema getAttribute(String attributeName) {
		return attributes.get(attributeName);
	}

	/**
	 * Returns definition of the associated data of particular name.
	 */
	@Nullable
	public AssociatedDataSchema getAssociatedData(String dataName) {
		return associatedData.get(dataName);
	}

	/**
	 * Returns definition of the facet associated with passed entity type.
	 */
	@Nullable
	public ReferenceSchema getReference(Serializable entityType) {
		return references.get(entityType);
	}

	/**
	 * Returns definition of the facet associated with passed entity type.
	 */
	@Nonnull
	public ReferenceSchema getReferenceOrThrowException(Serializable entityType) {
		final ReferenceSchema referenceSchema = references.get(entityType);
		Assert.isTrue(referenceSchema != null, () -> new IllegalStateException("Reference schema for entity `" + entityType + "` was not found in entity schema `" + name + "`."));
		return referenceSchema;
	}

	/**
	 * Creates builder that accepts changes over this immutable instance and that is able to produce changes to existing
	 * schema definition.
	 */
	@Nonnull
	public EntitySchemaBuilder open(UnaryOperator<EntitySchema> schemaUpdater) {
		return new EntitySchemaBuilder(this, schemaUpdater);
	}

	/**
	 * Returns true if schema supports locale in argument.
	 */
	public boolean supportsLocale(@Nonnull Locale locale) {
		return locales.contains(locale);
	}

	/**
	 * Returns true if schema allows evolution in certain form.
	 */
	public boolean allows(EvolutionMode evolutionMode) {
		return this.evolutionMode.contains(evolutionMode);
	}

	/**
	 * Returns true if passed schema represents the same type and si equally same or older.
	 */
	public boolean isCompatibleAndSameOrOlder(EntitySchema entitySchema) {
		return Objects.equals(getName(), entitySchema.getName()) &&
			getVersion() <= entitySchema.getVersion();
	}

	/**
	 * Returns true if this schema differs in any way from other schema. Executes full comparison logic of all contents.
	 */
	@Override
	public boolean differsFrom(@Nullable EntitySchema otherSchema) {
		if (this == otherSchema) return false;
		if (otherSchema == null || getClass() != otherSchema.getClass()) return true;

		if (version != otherSchema.version) return true;
		if (withGeneratedPrimaryKey != otherSchema.withGeneratedPrimaryKey) return true;
		if (withHierarchy != otherSchema.withHierarchy) return true;
		if (withPrice != otherSchema.withPrice) return true;
		if (!name.equals(otherSchema.name)) return true;
		if (!locales.equals(otherSchema.locales)) return true;

		if (attributes.size() != otherSchema.attributes.size()) return true;
		for (Entry<String, AttributeSchema> entry : attributes.entrySet()) {
			final AttributeSchema otherAttributeSchema = otherSchema.getAttribute(entry.getKey());
			if (otherAttributeSchema == null || !Objects.equals(entry.getValue(), otherAttributeSchema)) {
				return true;
			}
		}

		if (associatedData.size() != otherSchema.associatedData.size()) return true;
		for (Entry<String, AssociatedDataSchema> entry : associatedData.entrySet()) {
			final AssociatedDataSchema otherAssociatedDataSchema = otherSchema.getAssociatedData(entry.getKey());
			if (otherAssociatedDataSchema == null || !Objects.equals(entry.getValue(), otherAssociatedDataSchema)) {
				return true;
			}
		}

		if (references.size() != otherSchema.references.size()) return true;
		for (Entry<Serializable, ReferenceSchema> entry : references.entrySet()) {
			final ReferenceSchema otherFacetSchema = otherSchema.getReference(entry.getKey());
			if (otherFacetSchema == null || !Objects.equals(entry.getValue(), otherFacetSchema)) {
				return true;
			}
		}

		return !evolutionMode.equals(otherSchema.evolutionMode);
	}

}
