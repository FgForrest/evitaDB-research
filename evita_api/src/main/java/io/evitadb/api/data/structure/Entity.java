/*
 *                         _ _        ____  ____
 *               _____   _(_) |_ __ _|  _ \| __ )
 *              / _ \ \ / / | __/ _` | | | |  _ \
 *             |  __/\ V /| | || (_| | |_| | |_) |
 *              \___| \_/ |_|\__\__,_|____/|____/
 *
 *   Copyright (c) 2023
 *
 *   Licensed under the Business Source License, Version 1.1 (the "License");
 *   you may not use this file except in compliance with the License.
 *   You may obtain a copy of the License at
 *
 *   https://github.com/FgForrest/evitaDB/blob/main/LICENSE
 *
 *   Unless required by applicable law or agreed to in writing, software
 *   distributed under the License is distributed on an "AS IS" BASIS,
 *   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *   See the License for the specific language governing permissions and
 *   limitations under the License.
 */

package io.evitadb.api.data.structure;

import io.evitadb.api.data.EntityEditor.EntityBuilder;
import io.evitadb.api.data.*;
import io.evitadb.api.data.mutation.EntityMutation;
import io.evitadb.api.data.mutation.LocalMutation;
import io.evitadb.api.data.structure.ExistingEntityBuilder.ExistingEntityMutation;
import io.evitadb.api.exception.ContextMissingException;
import io.evitadb.api.io.extraResult.FacetSummary.FacetStatistics;
import io.evitadb.api.io.predicate.*;
import io.evitadb.api.query.Query;
import io.evitadb.api.query.filter.Language;
import io.evitadb.api.query.filter.PriceInPriceLists;
import io.evitadb.api.query.filter.PrimaryKey;
import io.evitadb.api.query.filter.WithinHierarchy;
import io.evitadb.api.query.require.Prices;
import io.evitadb.api.query.require.*;
import io.evitadb.api.schema.AssociatedDataSchema;
import io.evitadb.api.schema.AttributeSchema;
import io.evitadb.api.schema.EntitySchema;
import lombok.Getter;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.ThreadSafe;
import java.io.Serializable;
import java.math.BigDecimal;
import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

import static java.util.Optional.ofNullable;

/**
 * Based on our experience we've designed following data model for handling entities in Evita DB. Model is rather complex
 * but was designed to limit amount of data fetched from database and minimize an amount of data that are indexed and subject
 * to search.
 *
 * Minimal entity definition consists of:
 *
 * - entity type and
 * - primary key (even this is optional and may be autogenerated by the database).
 *
 * Other entity data is purely optional and may not be used at all.
 *
 * Class is immutable on purpose - we want to support caching the entities in a shared cache and accessed by many threads.
 * For altering the contents use {@link InitialEntityBuilder}.
 *
 * @author Jan Novotn√Ω (novotny@fg.cz), FG Forrest a.s. (c) 2021
 */
@Immutable
@ThreadSafe
public class Entity implements SealedEntity {
	private static final long serialVersionUID = 8637366499361070438L;

	/**
	 * Contains version of this object and gets increased with any (direct) entity update. Allows to execute
	 * optimistic locking i.e. avoiding parallel modifications.
	 */
	@Getter final int version;
	/**
	 * Serializable type of entity. Using Enum type is highly recommended for this key.
	 * Entity type is main sharding key - all data of entities with same type are stored in separated index. Within the
	 * entity type entity is uniquely represented by primary key.
	 * Type is specified in each lookup {@link Query#getEntities()}
	 */
	@Getter @Nonnull final Serializable type;
	/**
	 * Contains definition of the entity.
	 */
	@Getter @Nonnull final EntitySchema schema;
	/**
	 * Unique Integer positive number (max. 2<sup>63</sup>-1) representing the entity. Can be used for fast lookup for
	 * entity (entities). Primary key must be unique within the same entity type.
	 * May be left empty if it should be auto generated by the database.
	 * Entities can by looked up by primary key by using constraint {@link PrimaryKey}
	 */
	@Getter @Nullable final Integer primaryKey;
	/**
	 * Entities may be organized in hierarchical fashion. That means that entity may refer to single parent entity and may be
	 * referred by multiple child entities. Hierarchy is always composed of entities of same type.
	 * Each entity must be part of at most single hierarchy (tree).
	 * Hierarchy can limit returned entities by using filtering constraints {@link WithinHierarchy}. It's also used for
	 * computation of extra data - such as {@link Parents}. It can also invert type of returned entities in case requirement
	 * {@link HierarchyStatistics} is used.
	 */
	@Getter @Nullable final HierarchicalPlacementContract hierarchicalPlacement;
	/**
	 * Reference refer to other entities (of same or different entity type).
	 * Allows entity filtering (but not sorting) of the entities by using {@link io.evitadb.api.query.filter.Facet} constraint
	 * and statistics computation if when {@link FacetStatistics} requirement is used. Reference
	 * is uniquely represented by int positive number (max. 2<sup>63</sup>-1) and {@link Serializable} entity type and can be
	 * part of multiple reference groups, that are also represented by int and {@link Serializable} entity type.
	 *
	 * Reference id in one entity is unique and belongs to single reference group id. Among multiple entities reference may be part
	 * of different reference groups. Referenced entity type may represent type of another Evita entity or may refer
	 * to anything unknown to Evita that posses unique int key and is maintained by external systems (fe. tag assignment,
	 * group assignment, category assignment, stock assignment and so on). Not all these data needs to be present in
	 * Evita.
	 *
	 * References may carry additional key-value data linked to this entity relation (fe. item count present on certain stock).
	 */
	final Map<EntityReference, ReferenceContract> references;
	/**
	 * Entity (global) attributes allows defining set of data that are fetched in bulk along with the entity body.
	 * Attributes may be indexed for fast filtering ({@link AttributeSchema#isFilterable()}) or can be used to sort along
	 * ({@link AttributeSchema#isSortable()}). Attributes are not automatically indexed in order not to waste precious
	 * memory space for data that will never be used in search queries.
	 *
	 * Filtering in attributes is executed by using constraints like {@link io.evitadb.api.query.filter.And},
	 * {@link io.evitadb.api.query.filter.Not}, {@link io.evitadb.api.query.filter.Equals}, {@link io.evitadb.api.query.filter.Contains}
	 * and many others. Sorting can be achieved with {@link io.evitadb.api.query.order.Ascending},
	 * {@link io.evitadb.api.query.order.Descending} or others.
	 *
	 * Attributes are not recommended for bigger data as they are all loaded at once when {@link io.evitadb.api.query.require.Attributes}
	 * requirement is used. Large data that are occasionally used store in {@link @AssociatedData}.
	 */
	final io.evitadb.api.data.structure.Attributes attributes;
	/**
	 * Associated data carry additional data entries that are never used for filtering / sorting but may be needed to be fetched
	 * along with entity in order to present data to the target consumer (i.e. user / API / bot). Associated data may be stored
	 * in slower storage and may contain wide range of data types - from small ones (i.e. numbers, strings, dates) up to large
	 * binary arrays representingEntity entire files (i.e. pictures, documents).
	 *
	 * The search query must contain specific {@link io.evitadb.api.query.require.AssociatedData} requirement in order
	 * associated data are fetched along with the entity. Associated data are stored and fetched separately by their name.
	 */
	final io.evitadb.api.data.structure.AssociatedData associatedData;
	/**
	 * Prices are specific to a very few entities, but because correct price computation is very complex in e-commerce
	 * systems and highly affects performance of the entities filtering and sorting, they deserve first class support
	 * in entity model. It is pretty common in B2B systems single product has assigned dozens of prices for the different
	 * customers.
	 * <p>
	 * Specifying prices on entity allows usage of {@link io.evitadb.api.query.filter.PriceValidIn},
	 * {@link io.evitadb.api.query.filter.PriceBetween}, {@link QueryPriceMode}
	 * and {@link PriceInPriceLists} filtering constraints and also {@link io.evitadb.api.query.order.PriceAscending},
	 * {@link io.evitadb.api.query.order.PriceDescending} ordering of the entities. Additional requirements
	 * {@link PriceHistogram}, {@link Prices}
	 * can be used in query as well.
	 */
	final io.evitadb.api.data.structure.Prices prices;
	/**
	 * Contains set of all {@link Locale} that were used for localized {@link io.evitadb.api.data.structure.Attributes} or {@link io.evitadb.api.data.structure.AssociatedData} of
	 * this particular entity.
	 *
	 * Enables using {@link Language} filtering constraint in query.
	 */
	@Getter final Set<Locale> locales;
	/**
	 * Contains TRUE if entity was dropped - i.e. removed. Entities is not removed (unless tidying process
	 * does it), but are lying among other entities with tombstone flag. Dropped entities can be overwritten by
	 * a revived entity continuing with the versioning where it was stopped for the last time.
	 */
	@Getter private final boolean dropped;

	/**
	 * Entities are not meant to be constructed by the client code. Use {@link InitialEntityBuilder} to create new or update
	 * existing entities.
	 */
	Entity(
		int version, @Nonnull EntitySchema schema, @Nullable Integer primaryKey,
		@Nullable HierarchicalPlacementContract hierarchicalPlacement,
		@Nonnull Collection<ReferenceContract> references,
		@Nonnull io.evitadb.api.data.structure.Attributes attributes,
		@Nonnull io.evitadb.api.data.structure.AssociatedData associatedData,
		@Nonnull io.evitadb.api.data.structure.Prices prices,
		@Nonnull Set<Locale> locales,
		boolean dropped
	) {
		this.version = version;
		this.type = schema.getName();
		this.schema = schema;
		this.primaryKey = primaryKey;
		this.hierarchicalPlacement = hierarchicalPlacement;
		this.references = references
			.stream()
			.collect(
				Collectors.toUnmodifiableMap(
					ReferenceContract::getReferencedEntity,
					Function.identity()
				)
			);
		this.attributes = attributes;
		this.associatedData = associatedData;
		this.prices = prices;
		this.locales = Collections.unmodifiableSet(locales);
		this.dropped = dropped;
	}

	public Entity(@Nonnull Serializable type, @Nullable Integer primaryKey) {
		this.version = 1;
		this.type = type;
		this.schema = new EntitySchema(type);
		this.primaryKey = primaryKey;
		this.hierarchicalPlacement = null;
		this.references = Collections.emptyMap();
		this.attributes = new io.evitadb.api.data.structure.Attributes(this.schema);
		this.associatedData = null;
		this.prices = new io.evitadb.api.data.structure.Prices(1, Collections.emptySet(), PriceInnerRecordHandling.NONE);
		this.locales = Collections.emptySet();
		this.dropped = false;
	}

	/**
	 * Method allows to create copy of the entity object with up-to-date schema definition. Data of the entity keeps
	 * untouched.
	 */
	public static SealedEntity decorate(
		@Nonnull Entity entity,
		@Nonnull EntitySchema currentSchema,
		@Nonnull HierarchicalContractSerializablePredicate hierarchicalPlacementPredicate,
		@Nonnull AttributeValueSerializablePredicate attributePredicate,
		@Nonnull AssociatedDataValueSerializablePredicate associatedDataValuePredicate,
		@Nonnull ReferenceContractSerializablePredicate referencePredicate,
		@Nonnull PriceContractSerializablePredicate pricePredicate
	) {
		return new EntityDecorator(
			entity, currentSchema,
			hierarchicalPlacementPredicate,
			attributePredicate, associatedDataValuePredicate,
			referencePredicate, pricePredicate
		);
	}

	@Override
	@Nullable
	public <T extends Serializable & Comparable<?>> T getAttribute(@Nonnull String attributeName) {
		return attributes.getAttribute(attributeName);
	}

	@Override
	@Nullable
	public <T extends Serializable & Comparable<?>> T[] getAttributeArray(@Nonnull String attributeName) {
		return attributes.getAttributeArray(attributeName);
	}

	@Nullable
	@Override
	public AttributeValue getAttributeValue(@Nonnull String attributeName) {
		return attributes.getAttributeValue(attributeName);
	}

	@Override
	@Nullable
	public <T extends Serializable & Comparable<?>> T getAttribute(@Nonnull String attributeName, @Nonnull Locale locale) {
		return attributes.getAttribute(attributeName, locale);
	}

	@Override
	@Nullable
	public <T extends Serializable & Comparable<?>> T[] getAttributeArray(@Nonnull String attributeName, @Nonnull Locale locale) {
		return attributes.getAttributeArray(attributeName, locale);
	}

	@Nullable
	@Override
	public AttributeValue getAttributeValue(@Nonnull String attributeName, @Nonnull Locale locale) {
		return attributes.getAttributeValue(attributeName, locale);
	}

	@Override
	@Nullable
	public AttributeSchema getAttributeSchema(@Nonnull String attributeName) {
		return attributes.getAttributeSchema(attributeName);
	}

	@Override
	@Nonnull
	public Set<String> getAttributeNames() {
		return attributes.getAttributeNames();
	}

	@Nonnull
	@Override
	public Set<AttributeKey> getAttributeKeys() {
		return attributes.getAttributeKeys();
	}

	@Nonnull
	@Override
	public Collection<AttributeValue> getAttributeValues() {
		return attributes.getAttributeValues();
	}

	@Nonnull
	@Override
	public Collection<AttributeValue> getAttributeValues(@Nonnull String attributeName) {
		return attributes.getAttributeValues();
	}

	@Nonnull
	@Override
	public Set<Locale> getAttributeLocales() {
		return attributes.getAttributeLocales();
	}

	@Nullable
	@Override
	public <T extends Serializable> T getAssociatedData(@Nonnull String associatedDataName) {
		return associatedData.getAssociatedData(associatedDataName);
	}

	@Nullable
	@Override
	public <T extends Serializable> T getAssociatedData(@Nonnull String associatedDataName, Class<T> dtoType) {
		return associatedData.getAssociatedData(associatedDataName, dtoType);
	}

	@Nullable
	@Override
	public <T extends Serializable> T[] getAssociatedDataArray(@Nonnull String associatedDataName) {
		return associatedData.getAssociatedData(associatedDataName);
	}

	@Nullable
	@Override
	public AssociatedDataValue getAssociatedDataValue(@Nonnull String associatedDataName) {
		return associatedData.getAssociatedDataValue(associatedDataName);
	}

	@Nullable
	@Override
	public <T extends Serializable> T getAssociatedData(@Nonnull String associatedDataName, @Nonnull Locale locale) {
		return associatedData.getAssociatedData(associatedDataName, locale);
	}

	@Nullable
	@Override
	public <T extends Serializable> T getAssociatedData(@Nonnull String associatedDataName, @Nonnull Locale locale, Class<T> dtoType) {
		return associatedData.getAssociatedData(associatedDataName, locale, dtoType);
	}

	@Nullable
	@Override
	public <T extends Serializable> T[] getAssociatedDataArray(@Nonnull String associatedDataName, @Nonnull Locale locale) {
		return associatedData.getAssociatedData(associatedDataName, locale);
	}

	@Nullable
	@Override
	public AssociatedDataValue getAssociatedDataValue(@Nonnull String associatedDataName, @Nonnull Locale locale) {
		return ofNullable(associatedData.getAssociatedDataValue(associatedDataName, locale))
			.orElseGet(() -> associatedData.getAssociatedDataValue(associatedDataName));
	}

	@Nullable
	@Override
	public AssociatedDataSchema getAssociatedDataSchema(@Nonnull String associatedDataName) {
		return associatedData.getAssociatedDataSchema(associatedDataName);
	}

	@Nonnull
	@Override
	public Set<String> getAssociatedDataNames() {
		return associatedData.getAssociatedDataNames();
	}

	@Nonnull
	@Override
	public Set<AssociatedDataKey> getAssociatedDataKeys() {
		return associatedData.getAssociatedDataKeys();
	}

	@Nonnull
	@Override
	public Collection<AssociatedDataValue> getAssociatedDataValues() {
		return associatedData.getAssociatedDataValues();
	}

	@Nonnull
	@Override
	public Collection<AssociatedDataValue> getAssociatedDataValues(@Nonnull String associatedDataName) {
		return associatedData.getAssociatedDataValues();
	}

	@Nonnull
	@Override
	public Set<Locale> getAssociatedDataLocales() {
		return associatedData.getAssociatedDataLocales();
	}

	@Override
	public PriceContract getPrice(int priceId, @Nonnull Serializable priceList, @Nonnull Currency currency) {
		return prices.getPrice(priceId, priceList, currency);
	}

	@Nullable
	@Override
	public PriceContract getSellingPrice() throws ContextMissingException {
		throw new ContextMissingException();
	}

	@Nonnull
	@Override
	public List<PriceContract> getAllSellingPrices() {
		return getAllSellingPrices(null, null);
	}

	@Override
	public boolean hasPriceInInterval(@Nonnull BigDecimal from, @Nonnull BigDecimal to, @Nonnull QueryPriceMode queryPriceMode) throws ContextMissingException {
		throw new ContextMissingException();
	}

	@Nonnull
	@Override
	public Collection<PriceContract> getPrices() {
		return prices.getPrices();
	}

	@Nonnull
	@Override
	public PriceInnerRecordHandling getPriceInnerRecordHandling() {
		return prices.getPriceInnerRecordHandling();
	}

	@Override
	public int getPricesVersion() {
		return prices.getPricesVersion();
	}

	@Nonnull
	@Override
	public Collection<ReferenceContract> getReferences() {
		return references.values();
	}

	@Nonnull
	@Override
	public Collection<ReferenceContract> getReferences(Serializable referencedEntityType) {
		return references
			.values()
			.stream()
			.filter(it -> Objects.equals(referencedEntityType, it.getReferencedEntity().getType()))
			.collect(Collectors.toList());
	}

	@Nullable
	@Override
	public ReferenceContract getReference(Serializable referencedEntityType, int referencedEntityId) {
		return references.get(new EntityReference(referencedEntityType, referencedEntityId));
	}

	@Nonnull
	@Override
	public EntityBuilder open() {
		return new ExistingEntityBuilder(this);
	}

	@Nonnull
	@Override
	public EntityMutation withMutations(LocalMutation<?, ?>... localMutations) {
		return new ExistingEntityMutation(this, localMutations);
	}

	@Nonnull
	@Override
	public EntityMutation withMutations(Collection<LocalMutation<?, ?>> localMutations) {
		return new ExistingEntityMutation(this, localMutations);
	}

	@Override
	public int hashCode() {
		return Objects.hash(version, type, primaryKey);
	}

	@Override
	public boolean equals(Object o) {
		if (this == o) return true;
		if (o == null || getClass() != o.getClass()) return false;
		Entity entity = (Entity) o;
		return version == entity.version && type.equals(entity.type) && Objects.equals(primaryKey, entity.primaryKey);
	}

	@Override
	public String toString() {
		return describe();
	}

}
